# 3.2 研究基于特征的认证方法（两种模式）

## 概述

本项目研究的"基于特征的认证方法"采用两种模式：

1. **模式一**：基于射频指纹的快速轻量认证，直接消费物理层给出的判定结果
2. **模式二**：基于特征加密的强认证，利用特征派生密钥完成首包级的密码学验证

两种模式在接口上统一为"输入声明的MAC与必要上下文，输出布尔判定与可选的短时或长期准入票据"，在策略上遵循"先快后稳"的门控原则，即快速模式仅用于秒级放行与风险筛查，强认证在短时窗口内完成接力并承担会话期的安全性。

## 问题定位

本节解决的问题是：新接入节点在链路层如何证明"自己是登记过的那台设备"。

在3.3.1已经给出特征密钥K和会话密钥Ks的基础上，本项目设计了两种并行可选的认证模式：

- **模式一**：基于射频指纹的快速轻量认证模式，直接消费物理层给出的判定结果，在毫秒级给出"是否为登记设备"的结论
- **模式二**：基于特征密钥的强认证模式，利用特征派生密钥在首个接入报文内完成密码学验证

两种模式在接口上统一为：输入声明的标识（MAC/伪名）及必要上下文，输出认证结果（通过/拒绝）以及可选的准入票据和会话密钥。系统可根据业务需求和设备能力，选择其中任意一种模式完成认证。

---

## 模式一：基于射频指纹（RFF）的快速轻量认证技术方案

### 目标与定位

本模式面向"接入毫秒级放行"的需求，目标是在不改变现有物理层实现细节的前提下，直接消费物理层给出的RFF判定结果，在链路层完成一次简单、快速的"是否允许该设备接入"的决策：

- 如果判定结果可靠，通过链路层签发一张短期有效的会话/准入令牌
- 如果判定结果不通过，则直接拒绝本次接入，或者按策略引导设备转入模式二进行强认证

在该模式下，射频指纹的特征提取、模板匹配、挑战–响应等全部封装在物理层模块内部，链路层只关心一个布尔判定和少量质量元数据，不对底层特征做二次处理。

### 1. 接口与输入输出设计

从链路层视角，模式一的接口可以抽象为：

#### 输入

- **声明的设备标识DevID**：MAC 或伪名
- **物理层RFF模块返回的判定结果**：
  - `rff_pass ∈ {true, false}`：是否通过 RFF 匹配
  - `rff_score`：可选的匹配得分或置信度
  - 质量元数据：如snr（信噪比）、ver（RFF 模型版本）等
- **本地策略配置**：
  - 允许接入的注册设备列表
  - 分值阈值
  - 票据有效时间ttl等

#### 输出

- **认证决策**：accept / reject
- **对accept的设备，生成快速准入/会话令牌Token_fast**，包含：
  - 绑定的 DevID
  - 令牌生效时间与到期时间（秒级）
  - 允许的业务范围（例如仅允许发起强认证、发送少量管理帧等）
  - 令牌校验值（由本端管理密钥计算的截断 MAC），防止篡改
- 如需保护后续少量数据，还可以在"通过"后调用 3.3.1 生成会话密钥 Ks，并在令牌中记录相关参数，用于数据面加密

### 2. 工作机制与步骤

在链路层，模式一的工作流程可以简化为以下三个步骤：

#### 步骤一：接入请求与RFF判定接收

- 终端发送携带 DevID 的接入请求帧
- 物理层根据预先注册的RFF模板对该DevID做射频指纹匹配，在内部完成特征处理与判定
- 将结果以 `(rff_pass, rff_score, snr, ver, ...)` 的形式上报给链路层

#### 步骤二：链路层快速决策

链路层首先检查DevID是否在注册设备列表中：
- 若不在注册列表 → 直接 reject

对注册设备，依据rff_pass和策略阈值做快速判断：
- 若 `rff_pass = false`，或 `rff_score` 明显低于本地配置阈值 → 决策为 reject
- 若 `rff_pass = true` 且 `rff_score` 满足预置质量要求 → 决策为 accept
- 对于评分处于灰区的情况，可在策略层直接视为"不通过"，或根据业务需要要求终端尝试模式二强认证

#### 步骤三：签发快速会话/准入令牌

当决策为accept时，链路层本地生成快速令牌Token_fast，典型结构为：

```
Token_fast = {DevID, t_start, t_expire, policy, MAC(K_mgmt, DevID‖t_start‖t_expire‖policy)}
```

其中MAC用于令牌完整性校验。

在令牌有效期内：
- 链路层按照policy对该设备开放有限的接入权限，例如：
  - 允许发送模式二的强认证首包
  - 允许少量管理/信令帧
  - 数据面业务根据安全需求选择是否允许或限速

令牌到期后自动失效，如需继续接入，可重新触发模式一认证或转入模式二。

### 3. 模式一适用场景

从体系结构上，模式一并不依赖特征密钥K，可作为一条独立的快速认证路径使用。

在需要建立加密会话的场景中，可在模式一"通过"后调用 3.3.1 生成会话密钥Ks，并将Ks的标识与 Token_fast 联，用于后续数据保护。

在同时部署两种模式时，模式一提供"毫秒级快速筛查 + 秒级轻量接入"，适合：

- 接入请求频繁、对时延敏感的场景（如高密度物联网终端、无人机集群）
- 对长期安全性要求不极端、或后续还会通过模式二进行更强认证的业务

通过这种设计，模式一在链路层只做三件简单的事：
1. 接收RFF判定
2. 做一次布尔决策
3. 根据结果签发或拒绝短期令牌

既避免了在链路层重复实现复杂的物理层算法，为后续强认证和会话管理提供了一个统一、可控的快速入口。

---

## 模式二：基于特征加密的认证方案

### 目标与定位

模式二面向"先证后通的强安全接入"需求，以3.3.1中得到的特征密钥K为核心，在首个接入报文（AuthReq）内完成密码学意义上的身份校验，并将认证结果与时间窗、MAC、序号等会话上下文强绑定。

工作流程：

1. 设备端在指定时间窗内调用 3.3.1，从特征派生出稳定串 S、随机扰动值 L 和特征密钥 K / 会话密钥 Ks
2. 利用 K 生成伪名与认证标签 Tag，构造单报文认证请求 AuthReq
3. 验证端根据 AuthReq 中携带的上下文信息，在本地调用 3.3.1 复算 K′ / Ks′，重算 Tag′ 并比对
4. 认证通过后签发准入令牌 MAT，设备持 MAT 和 Ks 进入数据面通信

该模式在一个报文往返内完成"证明身份→授予令牌→建立会话密钥"的闭环，具有抗重放、抗克隆、跨会话不可链接等特性，适合作为高安全场景的主认证路径。

![MAC认证的设备端与验证端流程](图15)

### 1. 接口与输入输出设计

从链路层视角，模式二的接口统一为"输入特征密钥相关量与会话上下文，输出认证结果和准入/会话令牌"。

#### 输入

**来自 3.3.1 的输出**（设备端/验证端各自本地调用）：
- 稳定高熵特征串 S
- 当前时间窗的一次性随机扰动值 L（由epoch和nonce计算）
- 特征密钥K
- 会话密钥Ks
- 一致性摘要digest（特征选取掩码、门限、算法版本等配置的摘要）

**协议上下文信息**：
- 设备标识：源MAC/伪名 DevPseudo
- 目标MAC：验证节点MAC
- 时间窗编号epoch、随机数nonce、首包序号seq
- 算法标识algID、版本号ver
- 可选的特征窗口标识csi_id或窗口摘要csi_digest，用于绑定本次测量窗口（具体提取在 3.3.1 中完成）

#### 输出

- **认证结果**：accept / reject
- **对 accept 的设备**：
  - 准入令牌 MAT：用于标记该设备在当前域内的接入资格和权限
  - 会话密钥Ks：用于后续数据面帧的认证加密
- **对 reject 的设备**：
  - 失败原因码（未注册、特征不一致、Tag 校验失败等），用于策略调整或触发重测/降级路径

### 2. 设备侧认证流程（AuthReq 构造）

在模式二下，设备端的链路层认证流程可概括为：

#### 步骤一：特征采集与密钥生成（调用 3.3.1）

在指定时间窗内，物理层完成特征采集，设备链路层调用 3.3.1：

```
(S, L, K, Ks, digest) ← FeatureKeyGen(X, nonce, srcMAC, dstMAC, dom, ver, epoch, Ci)
```

其中L已由epoch和nonce计算得到，不再在本节展开。

#### 步骤二：生成伪名标识DevPseudo

为降低长期跟踪风险，设备基于K、epoch等参数生成本周期伪名DevPseudo，例如：

```
DevPseudo = Trunc₉₆(BLAKE3("Pseudo"‖K‖epoch))
```

DevPseudo与真实MAC在链路层可互相映射，但对外仅暴露伪名。

#### 步骤三：计算认证标签 Tag

设备利用特征密钥 K 对首个接入报文的关键信息进行绑定与完整性保护，例如：

```
Tag = Trunc₁₂₈(BLAKE3-MAC(K, SrcMAC‖DstMAC‖epoch‖nonce‖seq‖algID‖csi_id))
```

其中SrcMAC/DstMAC/epoch/seq不加密，但作为关联数据被认证，用于抗调包、抗错序与抗重放。

#### 步骤四：构造单报文认证请求 AuthReq

认证请求报文可采用自定义以太类型（如 0x88B5）或在 802.11 Vendor IE 中封装，其负载结构示意为：

```
AuthReq = {
    DevPseudo,      // 当前周期伪名（12B）
    csi_id,         // 本次特征测量窗口标识或摘要（4B）
    epoch,          // 时间窗编号
    nonce,          // 随机数
    seq,            // 首包序号
    algID,          // 算法标识
    ver,            // 版本号
    digest,         // 特征配置一致性摘要
    Tag             // 截断后的认证标签（如 16B）
}
```

#### 步骤五：发送AuthReq等待认证结果

- 设备发送 AuthReq 至验证节点，等待返回的认证结果和准入令牌 MAT
- 若接收到通过应答，则记录 MAT 和 Ks，进入数据面通信
- 若认证失败，可根据返回原因选择重新测量、重新发起认证或退网

### 3. 验证端认证流程与准入令牌签发

验证端收到AuthReq后，在链路层执行以下步骤：

#### 步骤一：设备与配置定位

- 根据DevPseudo或源MAC，在本地注册表中找到对应设备的注册信息与特征配置（算法版本、域标识dom等）
- 根据epoch, csi_id等字段确定应使用的特征窗口和时间窗上下文

#### 步骤二：特征密钥与会话密钥重构（调用 3.3.1）

验证端根据本地特征 X′ 和 AuthReq 中的上下文信息，调用 3.3.1：

```
(S′, L′, K′, Ks′, digest′) ← FeatureKeyGen(X′, nonce, srcMAC, dstMAC, dom, ver, epoch, Ci)
```

若特征窗口不匹配或 3.3.1 返回失败（深衰落等），可触发一次重测或直接给出失败判定（具体策略由3.3.3描述）。

#### 步骤三：配置一致性检查

若AuthReq中携带了digest，则先比较 digest′ 与 digest：
- 若不一致，说明双方特征配置或版本不一致，验证端可直接拒绝或要求重新协商配置
- 若一致，则进入标签校验

#### 步骤四：认证标签校验

验证端使用K′计算本地标签：

```
Tag′ = Trunc₁₂₈(BLAKE3-MAC(K′, SrcMAC‖DstMAC‖epoch‖nonce‖seq‖algID‖csi_id))
```

与AuthReq中的Tag做比较：
- 若 `Tag′ = Tag`，则认为该设备在当前时间窗内的特征与注册信息一致，认证通过
- 否则判定认证失败，拒绝接入

#### 步骤五：准入令牌 MAT 与会话状态签发

对认证通过的设备，验证端生成准入令牌 MAT，典型结构可为：

```
MAT = {
    issuerSet,      // 参与签发的验证节点集合（支持多验证者门限聚合）
    DevPseudo,      // 绑定的设备伪名
    epoch,          // 时间窗编号
    ttl,            // 有效期
    region,         // 区域标识
    mat_id,         // 令牌唯一标识
    sig_agg         // 聚合签名或 MAC，用于快速验票
}
```

根据部署需求，可采用：
- 单验证者签名
- 或在多个验证节点分别完成Tag校验后，由簇首进行门限聚合签名（如 3 选 2）

验证端将 MAT 及必要的会话参数（如Ks的标识）封装在认证应答报文中发回设备，并在本地记录Ks′，作为该设备当前会话的加密密钥。

### 4. 数据面保护与整体衔接（链路层视角概要）

接入认证通过后，双方使用会话密钥Ks对数据面帧进行认证加密：

- 典型实现是采用轻量级AEAD算法（如 Ascon-128a）
- 将SrcMAC/DstMAC/epoch/seq作为关联数据纳入认证，实现抗重放与抗错序

验证端对每个源设备维护滑动窗口与最高序号seq_highwater：
- 对旧窗口、重复序号和旧epoch的帧直接丢弃

epoch轮换、哈希链计数Ci的推进、MAT的更新与吊销、跨窗口双钥容忍等周期性机制，由 3.3.3"基于特征的周期变换同步机制"章节统一描述。

### 总结

通过上述流程，模式二将3.3.1的"特征→密钥"能力完整封装到首包认证流程中，链路层只需围绕AuthReq/AuthAck报文格式、Tag校验和MAT签发实现有限的逻辑，就可以在单次往返中完成强身份认证与会话建立。
