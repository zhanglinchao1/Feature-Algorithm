# 3.3.3 基于特征的周期变化同步机制 - 开发文档

## 1. 模块概述

### 1.1 模块目标
本模块实现分布式自组网环境下的周期同步机制，为3.3.1（特征加密算法）和3.3.2（认证方法）提供时间窗、特征参数、密钥轮换的统一同步基础。

### 1.2 核心功能
1. **时间窗同步与容错机制**：基于信标的epoch同步，支持多窗容忍
2. **特征参数同步与轮换**：导频计划、子载波子集、量化参数的周期轮换
3. **伪名/密钥/令牌轮换**：与epoch绑定的身份标识和凭证周期更新
4. **失步与重同步处理**：簇首切换、网络分区的容错恢复

### 1.3 测试场景约束
- **验证节点数量**：2个（支持簇首选举和互备）
- **设备节点数量**：≥1个
- **网络拓扑**：分布式自组网，无中心化控制

## 2. 系统架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│           3.3.3 周期变化同步机制模块                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ 时间窗同步   │  │ 特征参数同步  │  │ 状态轮换机制  │  │
│  │ 模块        │  │ 模块         │  │              │  │
│  │             │  │              │  │              │  │
│  │ - 信标广播   │  │ - 导频计划    │  │ - 伪名轮换    │  │
│  │ - epoch管理 │  │ - 子载波选择  │  │ - 密钥轮换    │  │
│  │ - 多窗容忍   │  │ - 参数版本    │  │ - 令牌轮换    │  │
│  └─────────────┘  └──────────────┘  └──────────────┘  │
│                                                         │
│  ┌─────────────────────────────────────────────────┐  │
│  │         失步处理与重同步模块                     │  │
│  │                                                 │  │
│  │  - 簇首选举(2选1)  - 信标超时处理              │  │
│  │  - 本地epoch推进   - 强制重同步                │  │
│  └─────────────────────────────────────────────────┘  │
│                                                         │
│  ┌─────────────────────────────────────────────────┐  │
│  │      分布式验证节点状态同步模块                  │  │
│  │                                                 │  │
│  │  - 验证节点间gossip协议                         │  │
│  │  - 吊销列表同步  - MAT状态同步                  │  │
│  └─────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
           ▲                          │
           │                          ▼
    ┌──────┴──────┐          ┌────────────────┐
    │ 3.3.1       │          │ 3.3.2          │
    │ 特征加密算法 │          │ 认证方法模块    │
    └─────────────┘          └────────────────┘
```

### 2.2 节点角色定义

#### 2.2.1 簇首节点（Cluster Head）
- **职责**：
  - 周期性广播同步信标（beacon）
  - 管理epoch时间窗
  - 发布特征参数配置
  - 聚合吊销信息

- **选举机制（2选1）**：
  ```
  优先级因素：
  1. 节点ID（预配置）
  2. 在线时长
  3. 心跳应答延迟

  选举算法：Bully算法简化版
  - 启动时，ID较大者广播ELECTION消息
  - 未收到更大ID的ANSWER，则自我宣告为簇首
  - 其他节点收到COORDINATOR消息后认可簇首
  ```

#### 2.2.2 验证节点（Validator）
- **职责**：
  - 接收并同步簇首信标
  - 本地维护epoch和特征配置
  - 执行设备认证（调用3.3.2）
  - 与其他验证节点同步状态

- **备份机制**：
  - 非簇首验证节点作为热备
  - 检测簇首失效并触发重选举

#### 2.2.3 设备节点（Device）
- **职责**：
  - 监听同步信标
  - 根据epoch进行特征测量
  - 触发认证流程（调用3.3.2）
  - 维护本地会话状态

### 2.3 关键数据结构

#### 2.3.1 同步信标（Beacon）
```python
@dataclass
class SyncBeacon:
    """同步信标结构"""

    # 基础时间信息
    epoch: int                    # 当前时间窗编号
    timestamp: int                # 信标生成时间戳(ms)
    delta_t: int                  # 时间窗周期(ms), 默认30000

    # 簇首信息
    cluster_head_id: bytes        # 簇首节点ID (6字节MAC)
    beacon_seq: int               # 信标序号

    # 特征参数配置
    feature_config: FeatureConfig # 特征参数配置

    # 完整性保护
    signature: bytes              # 簇首签名(32字节)

    def pack(self) -> bytes:
        """打包为字节流"""
        pass

    @staticmethod
    def unpack(data: bytes) -> 'SyncBeacon':
        """从字节流解包"""
        pass
```

#### 2.3.2 特征参数配置（FeatureConfig）
```python
@dataclass
class FeatureConfig:
    """特征参数配置"""

    # 配置版本
    version: int                  # 配置版本号
    config_id: bytes              # 配置唯一标识(16字节)

    # 导频计划
    pilot_plan: PilotPlan         # TDD导频时隙配置

    # 特征采集参数
    measurement_window_ms: int    # 测量窗口时长(ms)
    sample_count: int             # 采样帧数M，默认6

    # 子载波选择
    subcarrier_seed: bytes        # 子载波选择种子(8字节)
    subcarrier_count: int         # 选择的子载波数量

    # 量化参数
    quantization_alpha: float     # 量化门限系数α, 默认0.8

    # 一致性摘要
    digest: bytes                 # SHA256(所有参数), 32字节

    def compute_digest(self) -> bytes:
        """计算配置摘要"""
        pass

    def select_subcarriers(self, total: int) -> List[int]:
        """根据seed选择子载波索引"""
        pass
```

#### 2.3.3 导频计划（PilotPlan）
```python
@dataclass
class PilotPlan:
    """TDD导频时隙配置"""

    frame_duration_ms: int        # TDD帧周期(ms)
    pilot_slots: List[int]        # 导频时隙索引列表
    training_pattern: bytes       # 训练序列图案

    def get_pilot_times(self, epoch_start: int) -> List[int]:
        """获取epoch内的导频时刻"""
        pass
```

#### 2.3.4 周期状态（EpochState）
```python
@dataclass
class EpochState:
    """节点维护的周期状态"""

    # 当前时间窗
    current_epoch: int
    epoch_start_time: int         # epoch开始时间戳(ms)
    epoch_duration: int           # epoch持续时间(ms)

    # 特征配置
    current_config: FeatureConfig

    # 容错窗口
    tolerated_epochs: Set[int]    # 允许的epoch集合{epoch-1, epoch, epoch+1}

    # 双密钥状态（新旧切换期）
    active_keys: Dict[int, KeyMaterial]  # {epoch: KeyMaterial}

    # 同步状态
    last_beacon_time: int         # 最后收到信标的时间
    is_synchronized: bool         # 是否已同步

    def is_epoch_valid(self, epoch: int) -> bool:
        """检查epoch是否在容忍范围内"""
        return epoch in self.tolerated_epochs

    def update_epoch(self, new_epoch: int, config: FeatureConfig):
        """更新到新epoch"""
        pass

    def get_active_key(self, epoch: int) -> Optional[KeyMaterial]:
        """获取指定epoch的密钥材料"""
        return self.active_keys.get(epoch)
```

#### 2.3.5 密钥材料（KeyMaterial）
```python
@dataclass
class KeyMaterial:
    """与epoch绑定的密钥材料"""

    epoch: int                    # 绑定的时间窗

    # 由3.3.1生成的密钥（接口调用）
    feature_key: bytes            # 特征密钥K (32字节)
    session_key: bytes            # 会话密钥Ks (32字节)

    # 派生的标识
    pseudonym: bytes              # 伪名 (12字节)

    # 哈希链状态
    hash_chain_counter: int       # 计数器Ci

    # 有效期
    valid_from: int               # 生效时间戳
    valid_until: int              # 失效时间戳

    def is_valid(self, now: int) -> bool:
        """检查是否在有效期内"""
        return self.valid_from <= now <= self.valid_until

    @staticmethod
    def derive_pseudonym(feature_key: bytes, epoch: int, counter: int) -> bytes:
        """派生伪名"""
        # DevPseudo = Trunc96(HMAC(K, "psn" || epoch || Ci))
        pass
```

## 3. 核心算法设计

### 3.1 时间窗同步算法

#### 3.1.1 簇首信标广播
```python
class ClusterHead:
    """簇首节点"""

    def __init__(self, node_id: bytes, delta_t: int = 30000):
        self.node_id = node_id
        self.delta_t = delta_t
        self.current_epoch = 0
        self.beacon_seq = 0
        self.feature_config = self._init_feature_config()
        self.epoch_start_time = 0

    def start_beacon_broadcast(self, interval_ms: int = 5000):
        """启动信标广播（每5秒一次）"""
        while True:
            beacon = self._generate_beacon()
            self._broadcast_beacon(beacon)
            time.sleep(interval_ms / 1000.0)

    def _generate_beacon(self) -> SyncBeacon:
        """生成同步信标"""
        now = int(time.time() * 1000)

        # 检查是否需要推进epoch
        if now - self.epoch_start_time >= self.delta_t:
            self._advance_epoch()

        beacon = SyncBeacon(
            epoch=self.current_epoch,
            timestamp=now,
            delta_t=self.delta_t,
            cluster_head_id=self.node_id,
            beacon_seq=self.beacon_seq,
            feature_config=self.feature_config,
            signature=b''  # 待签名
        )

        # 签名
        beacon.signature = self._sign_beacon(beacon)
        self.beacon_seq += 1

        return beacon

    def _advance_epoch(self):
        """推进到下一个epoch"""
        self.current_epoch += 1
        self.epoch_start_time = int(time.time() * 1000)

        # 轮换特征配置（每N个epoch轮换一次）
        if self.current_epoch % 10 == 0:
            self._rotate_feature_config()

        logging.info(f"Epoch advanced to {self.current_epoch}")

    def _rotate_feature_config(self):
        """轮换特征参数配置"""
        # 生成新的子载波选择种子
        new_seed = secrets.token_bytes(8)

        self.feature_config = FeatureConfig(
            version=self.feature_config.version + 1,
            config_id=secrets.token_bytes(16),
            pilot_plan=self.feature_config.pilot_plan,  # 保持不变
            measurement_window_ms=200,
            sample_count=6,
            subcarrier_seed=new_seed,
            subcarrier_count=64,
            quantization_alpha=0.8,
            digest=b''
        )

        # 计算新摘要
        self.feature_config.digest = self.feature_config.compute_digest()

        logging.info(f"Feature config rotated, version={self.feature_config.version}")
```

#### 3.1.2 验证节点/设备节点信标接收
```python
class ValidatorNode:
    """验证节点"""

    def __init__(self, node_id: bytes):
        self.node_id = node_id
        self.epoch_state = EpochState(
            current_epoch=0,
            epoch_start_time=0,
            epoch_duration=30000,
            current_config=None,
            tolerated_epochs=set(),
            active_keys={},
            last_beacon_time=0,
            is_synchronized=False
        )
        self.beacon_timeout = 15000  # 15秒未收到信标认为失联

    def on_beacon_received(self, beacon: SyncBeacon) -> bool:
        """处理收到的信标"""
        # 1. 验证签名
        if not self._verify_beacon_signature(beacon):
            logging.warning("Beacon signature verification failed")
            return False

        # 2. 更新时间窗
        now = int(time.time() * 1000)
        self.epoch_state.last_beacon_time = now

        # 检查是否需要同步到新epoch
        if beacon.epoch > self.epoch_state.current_epoch:
            self._sync_to_epoch(beacon)
        elif beacon.epoch < self.epoch_state.current_epoch - 1:
            # 信标过旧，可能网络分区恢复，需要判断
            logging.warning(f"Received old beacon: {beacon.epoch} < {self.epoch_state.current_epoch}")
            return False

        # 3. 更新容忍窗口
        self._update_tolerated_epochs(beacon.epoch)

        # 4. 同步特征配置
        if beacon.feature_config.config_id != self.epoch_state.current_config.config_id:
            self._sync_feature_config(beacon.feature_config)

        self.epoch_state.is_synchronized = True
        return True

    def _sync_to_epoch(self, beacon: SyncBeacon):
        """同步到新的epoch"""
        old_epoch = self.epoch_state.current_epoch
        new_epoch = beacon.epoch

        logging.info(f"Syncing from epoch {old_epoch} to {new_epoch}")

        # 更新epoch状态
        self.epoch_state.current_epoch = new_epoch
        self.epoch_state.epoch_start_time = beacon.timestamp
        self.epoch_state.epoch_duration = beacon.delta_t

        # 清理旧密钥（保留上一个epoch的密钥用于容错）
        epochs_to_remove = [e for e in self.epoch_state.active_keys.keys()
                           if e < new_epoch - 1]
        for e in epochs_to_remove:
            del self.epoch_state.active_keys[e]
            logging.debug(f"Removed old key material for epoch {e}")

    def _update_tolerated_epochs(self, current_epoch: int):
        """更新容忍的epoch集合"""
        # 允许当前epoch及相邻的前后各1个epoch
        self.epoch_state.tolerated_epochs = {
            current_epoch - 1,
            current_epoch,
            current_epoch + 1
        }

    def _sync_feature_config(self, config: FeatureConfig):
        """同步特征配置"""
        # 验证摘要
        expected_digest = config.compute_digest()
        if config.digest != expected_digest:
            logging.error("Feature config digest mismatch")
            return

        self.epoch_state.current_config = config
        logging.info(f"Feature config synced, version={config.version}")

    def check_synchronization(self) -> bool:
        """检查同步状态"""
        now = int(time.time() * 1000)

        # 检查信标超时
        if now - self.epoch_state.last_beacon_time > self.beacon_timeout:
            self.epoch_state.is_synchronized = False
            logging.warning("Beacon timeout, entering local epoch progression mode")
            self._enter_local_progression()
            return False

        return self.epoch_state.is_synchronized

    def _enter_local_progression(self):
        """进入本地epoch推进模式"""
        # 基于上次同步的信息，继续推进epoch
        now = int(time.time() * 1000)
        elapsed = now - self.epoch_state.epoch_start_time

        if elapsed >= self.epoch_state.epoch_duration:
            # 本地推进epoch
            epochs_advanced = elapsed // self.epoch_state.epoch_duration
            self.epoch_state.current_epoch += epochs_advanced
            self.epoch_state.epoch_start_time += epochs_advanced * self.epoch_state.epoch_duration

            # 更新容忍窗口
            self._update_tolerated_epochs(self.epoch_state.current_epoch)

            logging.info(f"Local epoch progression to {self.epoch_state.current_epoch}")
```

### 3.2 伪名/密钥/令牌轮换算法

#### 3.2.1 密钥材料生成与轮换
```python
class KeyRotationManager:
    """密钥轮换管理器"""

    def __init__(self, node: ValidatorNode):
        self.node = node
        self.feature_key_engine = None  # 3.3.1接口（待集成）

    def generate_key_material(self, device_mac: bytes, epoch: int,
                             feature_vector: np.ndarray, nonce: bytes) -> KeyMaterial:
        """
        为指定设备和epoch生成密钥材料

        调用3.3.1的特征加密算法接口：
        S, L, K, Ks, digest = FeatureKeyEngine(X, srcMAC, dstMAC, dom, ver, epoch, nonce, Ci)
        """

        # TODO: 调用3.3.1接口
        # 这里暂时使用模拟实现
        feature_key, session_key = self._mock_derive_keys(
            device_mac, epoch, feature_vector, nonce
        )

        # 派生伪名
        hash_chain_counter = self._get_hash_chain_counter(device_mac, epoch)
        pseudonym = KeyMaterial.derive_pseudonym(feature_key, epoch, hash_chain_counter)

        # 计算有效期
        now = int(time.time() * 1000)
        epoch_duration = self.node.epoch_state.epoch_duration

        key_material = KeyMaterial(
            epoch=epoch,
            feature_key=feature_key,
            session_key=session_key,
            pseudonym=pseudonym,
            hash_chain_counter=hash_chain_counter,
            valid_from=now,
            valid_until=now + epoch_duration
        )

        return key_material

    def rotate_keys_on_epoch_change(self, device_mac: bytes,
                                    new_epoch: int, feature_vector: np.ndarray):
        """epoch切换时轮换密钥"""
        # 生成新epoch的密钥材料
        nonce = secrets.token_bytes(16)
        new_key_material = self.generate_key_material(
            device_mac, new_epoch, feature_vector, nonce
        )

        # 保存新密钥
        if new_epoch not in self.node.epoch_state.active_keys:
            self.node.epoch_state.active_keys[new_epoch] = {}

        self.node.epoch_state.active_keys[new_epoch][device_mac] = new_key_material

        logging.info(f"Keys rotated for device {device_mac.hex()} at epoch {new_epoch}")

        return new_key_material

    def get_key_material(self, device_mac: bytes, epoch: int) -> Optional[KeyMaterial]:
        """获取指定设备和epoch的密钥材料"""
        if epoch not in self.node.epoch_state.active_keys:
            return None

        return self.node.epoch_state.active_keys[epoch].get(device_mac)

    def _get_hash_chain_counter(self, device_mac: bytes, epoch: int) -> int:
        """获取哈希链计数器Ci"""
        # 简单实现：每个epoch递增
        return epoch

    def _mock_derive_keys(self, device_mac: bytes, epoch: int,
                          feature_vector: np.ndarray, nonce: bytes) -> Tuple[bytes, bytes]:
        """模拟密钥派生（待替换为3.3.1真实实现）"""
        import hashlib

        # 使用HKDF派生
        input_material = device_mac + epoch.to_bytes(4, 'big') + nonce

        # 特征密钥
        feature_key = hashlib.sha256(b"feature_key||" + input_material).digest()

        # 会话密钥
        session_key = hashlib.sha256(b"session_key||" + input_material).digest()

        return feature_key, session_key
```

#### 3.2.2 MAT令牌轮换
```python
@dataclass
class MATToken:
    """准入令牌（MAC Authentication Token）"""

    issuer_set: List[bytes]       # 签发验证节点集合
    device_pseudonym: bytes       # 设备伪名(12字节)
    epoch: int                    # 绑定的epoch
    ttl: int                      # 有效期(ms)
    region: str                   # 区域标识
    mat_id: bytes                 # 令牌唯一ID(16字节)
    issued_at: int                # 签发时间戳
    signature: bytes              # 聚合签名(64字节)

    def is_valid(self, now: int, current_epoch: int) -> bool:
        """检查令牌有效性"""
        # 检查时间
        if now > self.issued_at + self.ttl:
            return False

        # 检查epoch（允许相邻epoch）
        if abs(current_epoch - self.epoch) > 1:
            return False

        return True

    def pack(self) -> bytes:
        """序列化"""
        pass

    @staticmethod
    def unpack(data: bytes) -> 'MATToken':
        """反序列化"""
        pass


class MATManager:
    """MAT令牌管理器"""

    def __init__(self, validator_nodes: List[ValidatorNode]):
        self.validators = validator_nodes
        self.issued_tokens: Dict[bytes, MATToken] = {}  # {mat_id: MATToken}
        self.revoked_tokens: Set[bytes] = set()         # 吊销列表

    def issue_mat(self, device_pseudonym: bytes, epoch: int,
                  session_key: bytes) -> MATToken:
        """签发MAT令牌"""
        now = int(time.time() * 1000)

        mat = MATToken(
            issuer_set=[v.node_id for v in self.validators],
            device_pseudonym=device_pseudonym,
            epoch=epoch,
            ttl=30000,  # 30秒，与epoch周期一致
            region="default",
            mat_id=secrets.token_bytes(16),
            issued_at=now,
            signature=b''  # 待签名
        )

        # 聚合签名（简化版：只用第一个验证节点签名）
        mat.signature = self._aggregate_sign(mat)

        # 记录
        self.issued_tokens[mat.mat_id] = mat

        logging.info(f"MAT issued: {mat.mat_id.hex()} for device {device_pseudonym.hex()}")

        return mat

    def verify_mat(self, mat: MATToken, current_epoch: int) -> bool:
        """验证MAT令牌"""
        now = int(time.time() * 1000)

        # 检查是否被吊销
        if mat.mat_id in self.revoked_tokens:
            logging.warning(f"MAT {mat.mat_id.hex()} is revoked")
            return False

        # 检查有效性
        if not mat.is_valid(now, current_epoch):
            logging.warning(f"MAT {mat.mat_id.hex()} is invalid")
            return False

        # 验证签名
        if not self._verify_signature(mat):
            logging.warning(f"MAT {mat.mat_id.hex()} signature verification failed")
            return False

        return True

    def revoke_mat(self, mat_id: bytes):
        """吊销MAT令牌"""
        self.revoked_tokens.add(mat_id)
        logging.info(f"MAT {mat_id.hex()} revoked")

    def rotate_mats_on_epoch_change(self, new_epoch: int):
        """epoch切换时轮换MAT"""
        # 清理旧epoch的MAT
        old_mats = [mat_id for mat_id, mat in self.issued_tokens.items()
                   if mat.epoch < new_epoch - 1]

        for mat_id in old_mats:
            del self.issued_tokens[mat_id]
            logging.debug(f"Removed old MAT {mat_id.hex()}")

        # 清理旧吊销记录
        # TODO: 实现吊销列表的滑动窗口清理

    def _aggregate_sign(self, mat: MATToken) -> bytes:
        """聚合签名（简化实现）"""
        import hashlib

        # 计算MAT内容的哈希
        content = (
            b''.join(mat.issuer_set) +
            mat.device_pseudonym +
            mat.epoch.to_bytes(4, 'big') +
            mat.mat_id
        )

        return hashlib.sha256(content).digest()

    def _verify_signature(self, mat: MATToken) -> bool:
        """验证签名"""
        expected = self._aggregate_sign(mat)
        return mat.signature == expected
```

### 3.3 失步与重同步处理

#### 3.3.1 簇首选举算法（Bully算法简化版）
```python
class ClusterElection:
    """簇首选举管理"""

    def __init__(self, node_id: bytes, all_validators: List[bytes]):
        self.node_id = node_id
        self.all_validators = sorted(all_validators)  # 按ID排序
        self.current_cluster_head = None
        self.election_timeout = 5000  # 5秒
        self.last_heartbeat = 0

    def start_election(self) -> bytes:
        """
        启动选举流程
        返回：当选的簇首ID
        """
        logging.info(f"Node {self.node_id.hex()} starting election")

        # 找到比自己ID大的节点
        higher_nodes = [v for v in self.all_validators if v > self.node_id]

        if not higher_nodes:
            # 没有更大的ID，自己成为簇首
            self._become_cluster_head()
            return self.node_id
        else:
            # 向更大的ID发送ELECTION消息
            for node in higher_nodes:
                self._send_election_message(node)

            # 等待ANSWER消息
            answer_received = self._wait_for_answer(timeout=2000)

            if not answer_received:
                # 没有收到应答，自己成为簇首
                self._become_cluster_head()
                return self.node_id
            else:
                # 等待COORDINATOR消息
                new_head = self._wait_for_coordinator(timeout=3000)
                if new_head:
                    self.current_cluster_head = new_head
                    return new_head
                else:
                    # 超时，重新选举
                    return self.start_election()

    def _become_cluster_head(self):
        """成为簇首"""
        self.current_cluster_head = self.node_id
        logging.info(f"Node {self.node_id.hex()} became cluster head")

        # 向所有其他节点广播COORDINATOR消息
        for node in self.all_validators:
            if node != self.node_id:
                self._send_coordinator_message(node)

    def check_cluster_head_alive(self) -> bool:
        """检查簇首是否存活"""
        now = int(time.time() * 1000)

        if now - self.last_heartbeat > self.election_timeout:
            logging.warning("Cluster head seems dead, triggering re-election")
            return False

        return True

    def on_heartbeat_received(self, from_node: bytes):
        """收到心跳"""
        if from_node == self.current_cluster_head:
            self.last_heartbeat = int(time.time() * 1000)

    def _send_election_message(self, to_node: bytes):
        """发送ELECTION消息（待实现网络层）"""
        pass

    def _wait_for_answer(self, timeout: int) -> bool:
        """等待ANSWER消息（待实现）"""
        # TODO: 实现网络消息接收
        return False

    def _wait_for_coordinator(self, timeout: int) -> Optional[bytes]:
        """等待COORDINATOR消息（待实现）"""
        # TODO: 实现网络消息接收
        return None

    def _send_coordinator_message(self, to_node: bytes):
        """发送COORDINATOR消息（待实现网络层）"""
        pass
```

#### 3.3.2 重同步处理
```python
class ResyncHandler:
    """重同步处理器"""

    def __init__(self, node: ValidatorNode):
        self.node = node
        self.max_local_progression_epochs = 5  # 最多本地推进5个epoch
        self.local_progression_count = 0

    def handle_desynchronization(self):
        """处理失步情况"""
        logging.warning("Node desynchronized, attempting recovery")

        # 1. 尝试本地推进
        if self.local_progression_count < self.max_local_progression_epochs:
            self._local_epoch_progression()
            self.local_progression_count += 1
            return

        # 2. 达到本地推进上限，强制重同步
        logging.error("Max local progression reached, forcing resynchronization")
        self._force_resynchronization()

    def _local_epoch_progression(self):
        """本地epoch推进"""
        now = int(time.time() * 1000)
        elapsed = now - self.node.epoch_state.epoch_start_time

        # 推进epoch
        if elapsed >= self.node.epoch_state.epoch_duration:
            epochs_to_advance = elapsed // self.node.epoch_state.epoch_duration

            for _ in range(int(epochs_to_advance)):
                self.node.epoch_state.current_epoch += 1
                self.node.epoch_state.epoch_start_time += self.node.epoch_state.epoch_duration

                # 更新容忍窗口
                self.node._update_tolerated_epochs(self.node.epoch_state.current_epoch)

                logging.info(f"Local epoch progression to {self.node.epoch_state.current_epoch}")

    def _force_resynchronization(self):
        """强制重同步"""
        # 1. 重置本地状态
        self.node.epoch_state.is_synchronized = False
        self.local_progression_count = 0

        # 2. 清空旧密钥
        self.node.epoch_state.active_keys.clear()

        # 3. 请求新的信标（待实现网络层）
        # TODO: 发送SYNC_REQUEST消息到簇首

        logging.info("Forced resynchronization initiated")

    def on_resync_successful(self, beacon: SyncBeacon):
        """重同步成功"""
        self.local_progression_count = 0
        self.node.on_beacon_received(beacon)
        logging.info("Resynchronization successful")
```

### 3.4 分布式验证节点状态同步

#### 3.4.1 Gossip协议实现
```python
class GossipProtocol:
    """验证节点间Gossip协议"""

    def __init__(self, local_node: ValidatorNode, peer_nodes: List[bytes]):
        self.local_node = local_node
        self.peer_nodes = peer_nodes
        self.gossip_interval = 3000  # 3秒
        self.state_version = 0

        # 需要同步的状态
        self.revocation_list: Set[bytes] = set()  # 吊销的MAT ID
        self.mat_cache: Dict[bytes, MATToken] = {}  # MAT缓存

    def start_gossip(self):
        """启动gossip循环"""
        while True:
            self._gossip_round()
            time.sleep(self.gossip_interval / 1000.0)

    def _gossip_round(self):
        """执行一轮gossip"""
        # 随机选择一个peer
        if not self.peer_nodes:
            return

        peer = random.choice(self.peer_nodes)

        # 构造gossip消息
        msg = self._build_gossip_message()

        # 发送给peer（待实现网络层）
        self._send_gossip(peer, msg)

        logging.debug(f"Gossip sent to {peer.hex()}")

    def _build_gossip_message(self) -> dict:
        """构造gossip消息"""
        return {
            'type': 'GOSSIP',
            'from': self.local_node.node_id,
            'version': self.state_version,
            'revocation_list': list(self.revocation_list),
            'mat_count': len(self.mat_cache),
            'epoch': self.local_node.epoch_state.current_epoch
        }

    def on_gossip_received(self, msg: dict, from_peer: bytes):
        """处理收到的gossip消息"""
        # 合并吊销列表
        peer_revocations = set(msg.get('revocation_list', []))
        new_revocations = peer_revocations - self.revocation_list

        if new_revocations:
            self.revocation_list.update(new_revocations)
            self.state_version += 1
            logging.info(f"Merged {len(new_revocations)} new revocations from {from_peer.hex()}")

        # 检查epoch差异
        peer_epoch = msg.get('epoch', 0)
        if abs(peer_epoch - self.local_node.epoch_state.current_epoch) > 1:
            logging.warning(f"Large epoch gap with peer {from_peer.hex()}: "
                          f"local={self.local_node.epoch_state.current_epoch}, peer={peer_epoch}")

    def _send_gossip(self, peer: bytes, msg: dict):
        """发送gossip消息（待实现网络层）"""
        # TODO: 实现UDP/TCP发送
        pass
```

## 4. 接口定义

### 4.1 对外接口（供3.3.2认证模块调用）

```python
class SynchronizationService:
    """同步服务统一接口"""

    def __init__(self, node_type: str, node_id: bytes,
                 peer_validators: List[bytes] = None):
        """
        初始化同步服务

        Args:
            node_type: 'cluster_head', 'validator', 或 'device'
            node_id: 节点ID（MAC地址）
            peer_validators: 其他验证节点列表（仅验证节点需要）
        """
        self.node_type = node_type
        self.node_id = node_id

        if node_type == 'cluster_head':
            self.cluster_head = ClusterHead(node_id)
            self.validator = ValidatorNode(node_id)
        elif node_type == 'validator':
            self.validator = ValidatorNode(node_id)
            self.election = ClusterElection(node_id, [node_id] + peer_validators)
        elif node_type == 'device':
            self.device = DeviceNode(node_id)
        else:
            raise ValueError(f"Unknown node type: {node_type}")

        self.key_rotation = KeyRotationManager(self.validator if hasattr(self, 'validator') else None)
        self.mat_manager = None  # 仅验证节点需要

    def start(self):
        """启动同步服务"""
        if self.node_type == 'cluster_head':
            # 启动信标广播
            threading.Thread(target=self.cluster_head.start_beacon_broadcast, daemon=True).start()
        elif self.node_type == 'validator':
            # 启动簇首选举
            self.election.start_election()

        logging.info(f"{self.node_type} synchronization service started")

    def get_current_epoch(self) -> int:
        """获取当前epoch"""
        if hasattr(self, 'validator'):
            return self.validator.epoch_state.current_epoch
        elif hasattr(self, 'device'):
            return self.device.epoch_state.current_epoch
        return 0

    def is_epoch_valid(self, epoch: int) -> bool:
        """检查epoch是否在容忍范围内"""
        if hasattr(self, 'validator'):
            return self.validator.epoch_state.is_epoch_valid(epoch)
        elif hasattr(self, 'device'):
            return self.device.epoch_state.is_epoch_valid(epoch)
        return False

    def get_feature_config(self) -> FeatureConfig:
        """获取当前特征配置"""
        if hasattr(self, 'validator'):
            return self.validator.epoch_state.current_config
        elif hasattr(self, 'device'):
            return self.device.epoch_state.current_config
        return None

    def get_key_material(self, device_mac: bytes, epoch: int) -> Optional[KeyMaterial]:
        """
        获取密钥材料（供3.3.2认证使用）

        Args:
            device_mac: 设备MAC地址
            epoch: 时间窗编号

        Returns:
            KeyMaterial或None
        """
        return self.key_rotation.get_key_material(device_mac, epoch)

    def generate_or_get_key_material(self, device_mac: bytes, epoch: int,
                                    feature_vector: np.ndarray,
                                    nonce: bytes) -> KeyMaterial:
        """
        生成或获取密钥材料

        如果已存在则返回，否则生成新的
        """
        # 先尝试获取
        existing = self.get_key_material(device_mac, epoch)
        if existing and existing.is_valid(int(time.time() * 1000)):
            return existing

        # 不存在或已过期，生成新的
        return self.key_rotation.generate_key_material(
            device_mac, epoch, feature_vector, nonce
        )

    def issue_mat_token(self, device_pseudonym: bytes, epoch: int,
                       session_key: bytes) -> MATToken:
        """签发MAT令牌（仅验证节点）"""
        if self.mat_manager is None:
            raise RuntimeError("MAT manager not initialized")

        return self.mat_manager.issue_mat(device_pseudonym, epoch, session_key)

    def verify_mat_token(self, mat: MATToken) -> bool:
        """验证MAT令牌（仅验证节点）"""
        if self.mat_manager is None:
            raise RuntimeError("MAT manager not initialized")

        current_epoch = self.get_current_epoch()
        return self.mat_manager.verify_mat(mat, current_epoch)

    def revoke_mat_token(self, mat_id: bytes):
        """吊销MAT令牌（仅验证节点）"""
        if self.mat_manager is None:
            raise RuntimeError("MAT manager not initialized")

        self.mat_manager.revoke_mat(mat_id)
```

### 4.2 对3.3.1的依赖接口

```python
# 3.3.1需要提供的接口（待3.3.1模块实现）
class FeatureKeyEngineInterface:
    """特征密钥引擎接口（由3.3.1实现）"""

    @staticmethod
    def derive_keys(
        feature_vector: np.ndarray,  # 特征向量X
        src_mac: bytes,              # 源MAC
        dst_mac: bytes,              # 目标MAC
        domain: str,                 # 域标识
        version: int,                # 算法版本
        epoch: int,                  # 时间窗编号
        nonce: bytes,                # 随机数
        hash_chain_counter: int      # 哈希链计数器Ci
    ) -> Tuple[bytes, bytes, bytes, bytes, bytes]:
        """
        从特征派生密钥

        Returns:
            (S, L, K, Ks, digest)
            - S: 稳定高熵特征串(32字节)
            - L: 一次性随机扰动值(32字节)
            - K: 特征密钥(32字节)
            - Ks: 会话密钥(32字节)
            - digest: 一致性摘要(32字节)
        """
        raise NotImplementedError("To be implemented by 3.3.1 module")
```

## 5. 测试设计

### 5.1 单元测试

```python
# tests/test_sync_beacon.py
def test_beacon_generation():
    """测试信标生成"""
    ch = ClusterHead(node_id=b'\x00' * 6)
    beacon = ch._generate_beacon()

    assert beacon.cluster_head_id == b'\x00' * 6
    assert beacon.epoch >= 0
    assert beacon.delta_t == 30000
    assert len(beacon.signature) > 0

def test_beacon_serialization():
    """测试信标序列化"""
    # TODO: 实现

def test_epoch_advancement():
    """测试epoch推进"""
    # TODO: 实现
```

```python
# tests/test_key_rotation.py
def test_key_material_generation():
    """测试密钥材料生成"""
    # TODO: 实现

def test_pseudonym_derivation():
    """测试伪名派生"""
    # TODO: 实现

def test_key_rotation_on_epoch_change():
    """测试epoch切换时的密钥轮换"""
    # TODO: 实现
```

```python
# tests/test_cluster_election.py
def test_election_with_two_nodes():
    """测试2节点选举"""
    node1 = b'\x00\x00\x00\x00\x00\x01'
    node2 = b'\x00\x00\x00\x00\x00\x02'

    election = ClusterElection(node1, [node1, node2])
    winner = election.start_election()

    # node2的ID更大，应当选为簇首
    assert winner == node2
```

### 5.2 集成测试（2验证节点 + 1设备节点）

```python
# tests/test_integration_sync.py
import pytest
import time

def test_two_validators_one_device_sync():
    """
    集成测试：2个验证节点 + 1个设备节点

    测试流程：
    1. 初始化2个验证节点
    2. 进行簇首选举
    3. 簇首开始广播信标
    4. 另一验证节点同步epoch
    5. 设备节点加入网络并同步
    6. 验证所有节点epoch一致
    7. 推进epoch，验证密钥轮换
    8. 模拟簇首失效，验证重选举
    """

    # 1. 初始化节点
    validator1_id = b'\x00\x00\x00\x00\x00\x01'
    validator2_id = b'\x00\x00\x00\x00\x00\x02'
    device_id = b'\x00\x00\x00\x00\x00\x03'

    validator1 = SynchronizationService('validator', validator1_id, [validator2_id])
    validator2 = SynchronizationService('validator', validator2_id, [validator1_id])
    device = SynchronizationService('device', device_id)

    # 2. 簇首选举（node2 ID更大）
    validator1.start()
    validator2.start()

    time.sleep(1)  # 等待选举完成

    # 验证node2成为簇首
    assert validator2.election.current_cluster_head == validator2_id

    # 3. 同步测试
    time.sleep(6)  # 等待一次信标广播

    # 验证epoch同步
    epoch1 = validator1.get_current_epoch()
    epoch2 = validator2.get_current_epoch()
    assert epoch1 == epoch2

    # 4. 设备节点同步
    # TODO: 实现设备节点加入和同步

    # 5. epoch推进测试
    # TODO: 模拟时间推进

    # 6. 簇首失效测试
    # TODO: 模拟簇首失效和重选举

def test_epoch_tolerance_window():
    """测试epoch容忍窗口"""
    # TODO: 验证相邻epoch的请求都能被接受

def test_feature_config_rotation():
    """测试特征配置轮换"""
    # TODO: 验证配置轮换和摘要一致性

def test_mat_token_lifecycle():
    """测试MAT令牌生命周期"""
    # TODO: 签发、验证、轮换、吊销
```

## 6. 实现计划

### 6.1 开发阶段

**阶段1：核心数据结构和序列化（2天）**
- [ ] 实现SyncBeacon、FeatureConfig等数据类
- [ ] 实现序列化/反序列化方法
- [ ] 编写单元测试

**阶段2：时间窗同步机制（3天）**
- [ ] 实现ClusterHead信标广播
- [ ] 实现ValidatorNode信标接收和同步
- [ ] 实现epoch推进逻辑
- [ ] 实现多窗容忍机制
- [ ] 编写单元测试

**阶段3：密钥轮换机制（3天）**
- [ ] 实现KeyRotationManager
- [ ] 实现伪名派生
- [ ] 实现密钥轮换逻辑
- [ ] 与3.3.1接口集成（Mock实现）
- [ ] 编写单元测试

**阶段4：MAT令牌管理（2天）**
- [ ] 实现MATManager
- [ ] 实现令牌签发、验证、吊销
- [ ] 实现令牌轮换
- [ ] 编写单元测试

**阶段5：簇首选举和失步处理（3天）**
- [ ] 实现ClusterElection（Bully算法）
- [ ] 实现ResyncHandler
- [ ] 实现本地epoch推进
- [ ] 实现强制重同步
- [ ] 编写单元测试

**阶段6：分布式状态同步（2天）**
- [ ] 实现GossipProtocol
- [ ] 实现吊销列表同步
- [ ] 编写单元测试

**阶段7：集成测试（3天）**
- [ ] 搭建2验证节点+1设备节点测试环境
- [ ] 编写端到端集成测试
- [ ] 性能测试和优化

**阶段8：文档和交付（2天）**
- [ ] 完善API文档
- [ ] 编写使用示例
- [ ] 代码审查和重构

### 6.2 依赖关系

- **对3.3.1的依赖**：需要FeatureKeyEngine接口，阶段3之前提供Mock实现
- **对3.3.2的依赖**：本模块为3.3.2提供服务，需要定义清晰的接口
- **网络层依赖**：需要UDP/TCP通信模块支持信标广播和gossip

### 6.3 风险和缓解措施

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 3.3.1接口延迟 | 阻塞密钥轮换测试 | 先用Mock实现，后期替换 |
| 网络层不稳定 | 影响同步可靠性 | 实现重传和超时机制 |
| 时钟漂移过大 | epoch不一致 | 加大容忍窗口，增加校准机制 |
| 选举冲突 | 双簇首 | 增加选举超时和冲突检测 |

## 7. 关键参数配置

```python
# config/sync_config.py
SYNC_CONFIG = {
    # 时间窗参数
    'epoch_duration_ms': 30000,          # epoch周期：30秒
    'beacon_interval_ms': 5000,          # 信标广播间隔：5秒
    'beacon_timeout_ms': 15000,          # 信标超时：15秒

    # 容错参数
    'epoch_tolerance_window': 1,         # 容忍相邻±1个epoch
    'max_local_progression_epochs': 5,   # 最多本地推进5个epoch

    # 选举参数
    'election_timeout_ms': 5000,         # 选举超时：5秒
    'heartbeat_interval_ms': 2000,       # 心跳间隔：2秒

    # Gossip参数
    'gossip_interval_ms': 3000,          # Gossip间隔：3秒
    'gossip_fanout': 1,                  # Gossip扇出：1（只有2个验证节点）

    # 特征配置轮换
    'feature_config_rotation_epochs': 10,  # 每10个epoch轮换一次

    # MAT令牌
    'mat_ttl_ms': 30000,                 # MAT有效期：30秒
}
```

## 8. 附录

### 8.1 消息格式定义

```python
# 信标消息格式（UDP广播）
# 格式：TLV编码
# Type(1B) | Length(2B) | Value(变长)

BEACON_MESSAGE_FORMAT = {
    'type': 0x01,
    'fields': [
        ('epoch', 'uint32'),
        ('timestamp', 'uint64'),
        ('delta_t', 'uint32'),
        ('cluster_head_id', 'bytes6'),
        ('beacon_seq', 'uint32'),
        ('feature_config', 'nested'),
        ('signature', 'bytes64'),
    ]
}

# 选举消息格式
ELECTION_MESSAGE = {'type': 0x10, 'from': 'bytes6'}
ANSWER_MESSAGE = {'type': 0x11, 'from': 'bytes6'}
COORDINATOR_MESSAGE = {'type': 0x12, 'cluster_head': 'bytes6'}

# Gossip消息格式
GOSSIP_MESSAGE = {
    'type': 0x20,
    'from': 'bytes6',
    'version': 'uint32',
    'revocation_list': 'list[bytes16]',
    'epoch': 'uint32',
}
```

### 8.2 状态机图

```
簇首节点状态机：
  [启动] -> [初始化] -> [开始广播] -> [周期广播信标] -> [推进epoch] -> [轮换配置]
                                        ↑__________________|

验证节点状态机：
  [启动] -> [选举] -> [非簇首] -> [接收信标] -> [同步epoch] -> [容忍窗口更新]
                         ↓                           ↑
                    [簇首失效] -> [重新选举] --------|

  [失步] -> [本地推进] -> [达到上限] -> [强制重同步]

设备节点状态机：
  [启动] -> [监听信标] -> [同步epoch] -> [正常运行]
                ↓             ↑
           [超时] -> [本地推进] -> [重新监听]
```

---

**文档版本**：v1.0
**创建日期**：2025-11-19
**作者**：Claude
**状态**：待审核
